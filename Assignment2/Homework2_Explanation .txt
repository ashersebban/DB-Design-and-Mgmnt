	The data set I used compiles a list of completed chess games. At first, the data set had 16 columns, namely: id, rated, created at, last move at, turns, victory status, winner, increment_code, white_id, white_rating, black_id, black_rating, moves, opening_eco, opening_name, and opening_ply. To explain the meaning of these columns and why I chose to include/exclude certain data, I will first provide relevant information about the game of chess itself. 
	Chess is a competition between two players, one playing white and the other playing black. White goes first and black responds. However, what many do not know about chess, is that specifically in the beginning of the game, high level players actually follow a predetermined pattern of moves. These patterns are called “openings”. If white initiates the game, say, by moving his king-pawn up two squares, this is called the “King-Pawn Opening”. If black responds by moving his queen-bishop-pawn up two squares, this is called the “Sicilian Defense”. This system of classifying moves goes on and on until the opening stage of the game is complete and the players enter what is called the “mid-game”. Another important fact about chess is the rating system. Professional and tournament chess players have what is known as a rating. Beginners usually fall below 1000, 1200-1400 is class D, 1400-1600 is class C, 1600-1800 is class B, 1800-2000 is class A, and 2000 and above is reserved for chess masters (in which there is its own rating system, for example, 2700+ is typically for World Championship contenders). The way the rating works is that one’s rating improves when they play what is called a “rated game”, This is when both players consent to playing with their rating at stake. The victor essentially wins some of the loser’s rating points. 
	The goal of my program was to discover which opening in the dataset was used most often to beat players with a higher rating. This is for personal use so I was only interested in games where players were above a 1500 (my current rating). I also wanted to rely on rated games only, as non rated games tend to be more experimental and more unreliable. Next, I had to “scrub” the data for games in which only the “underdog” was the winner since I am only interested in games where the “lesser” player was victorious. In my code, I specifically required that the underdog had to be at least 100 points less than his opponent to avoid retrieving games in which the “underdog” was the same level as his opponent. Finally, I reordered the output file to display “underdog wins” as black and as white. Then I reordered the list by opening to finally see which openings to use as both black and white when playing better opponents. 
	Thus, out of the initial 16 columns, the only relevant columns to display were: white_rating, black_rating, victor, moves, opening name, and opening ply (secondary openings within an opening). Although not displayed, I also used the “rated” column to ensure that all values were in fact “TRUE” (as in, they were indeed rated games). After my scrubbing, I successfully turned 20,059 rows into a mere 397. In addition, I also gave the option for users to see the actual game log (ie. the series of moves for the entire game). This is useful for me personally in case I want to follow how each player was able to win. Should the user respond that they indeed want to see the game log, I also included the column “turns” which display the total number of moves for the game. 