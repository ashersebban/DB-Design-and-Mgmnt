Asher Sebban
Prof. Engel
Database Design
2/28/2019
PANDAS Explained
	In chess, the shortest checkmate possible is called the "4 Move Checkmate”. Therefore, any games that have less than 8 total moves (4 for each player) are automatically invalid. My first query highlights these games as “BAD DATA”, while sorting all other game into a new set: “VIABLE DATA”.
	However, simply because a game has more than 8 moves does not mean it is usable data. In chess, players can win with 'checkmate' but they can also win if their opponent resigns or runs out of time. The latter two victory types are just as valid as any, however, they also pose  potential problems for data analysis. The data in my program represents chess games played online. Therefore, if a player started a game but resigned quickly, it might mean they simply had to leave. If a player ran out of time, but only played a few moves, it might mean they got distracted and ran out of time by accident. In truth, any game that was not decided by checkmate could be potentially problematic; the reason all games are included, is because it is common courtesy in chess to resign if all hope is lost. Many games that end in a resignation, would have ended in checkmate if the game continued. Therefore, it is much more likely that a resignation after 80 moves still has usable data, while a resignation after 20 moves may not. Games not decided by checkmate that have under 30 moves need to be individually reviewed. 30 moves is an arbitrary number around the bottom 15th percentile (total moves). These games must be individually reviewed to ascertain whether the games are valid. This is impossible to do without a powerful chess computer, so I must personally view each game log, play out the game at home, and analyze the final position. 
	Once I highlighted the bad and potentially bad data, I can finally move on. My initial goal was to find the best opening when playing a more advanced player. In chess, black has different opening moves than white does. Therefore, the next step was to separate games won by white and games won by black. My program then displays the total amount of games won by white, as well as the top 5 most common openings as white. Then, my program asks the user whether they would like to view the data. Any input other than “yes”, will result in the data viewer turning off. My program then does the same thing for all the black games.   	Finally, my program is complete. However, I threw in two more queries that I thought would display the most interesting data. The first is a list of the 20 largest upsets in the data set. The second is a list of upsets where a non-master beat a grandmaster. For both these queries, the user is given the choice whether they would like to view them. Lastly, I tried to code an ELO finder, which is not currently working. What is supposed to happen is the user inputs the Opening Code (A00), and the program spits out the Opening Name (Anderssen Opening). I’ll probably figure it out eventually. 

The kill code for my program is: off. 